#!/usr/bin/env python

import sys
import os
import subprocess


def error(msg):
    print("ERROR: " + msg)


def fatal(msg):
    print(msg)
    exit(1)


def usage(exit_code=0):
    print("mkproj <project_name> <language> [base_directory]")
    exit(exit_code)


def getenv(key):
    return os.environ[key]


def cd(dir):
    os.chdir(dir)


def pwd():
    return os.getcwd()


def mkdir(*dir_paths):
    for p in dir_paths:
        os.makedirs(p)


def touch(*files):
    for file in files:
        f = open(file, "w+")
        f.close()


def nonemptyinput(prompt):
    line = input(prompt)
    if line is None or line == '':
        fatal("empty line read")
    
    return line


def oneof(v, *values):
    for value in values:
        if v == value:
            return True
    
    return False


def get_project_details(argc, argv):
    project_name = argv[1]
    project_lang = argv[2]
    
    base_dir = argv[3] if argc == 4 else pwd()
    if not os.path.isdir(base_dir):
        fatal("'%s' is not a dir" % base_dir)

    project_dir = base_dir + "/" + project_name
    if os.path.isdir(project_dir):
        fatal("project directory '%s' already exists" % project_dir)

    return (project_name, project_lang, project_dir)

def generate_build_instructions(project_lang):
    pl = project_lang.lower()
    
    build_instructions = ""
    if oneof(pl, "c", "cxx"):
        build_instructions = """
This is a classic out-of-source CMake build. Run the following in the root of your source tree:

```
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=release ..
cmake --build .
```
""".strip()
    else:
        build_instructions = "how to build your project"

    return build_instructions

def generate_install_instructions(project_lang):
    pl = project_lang.lower()

    install_instructions = ""
    if oneof(pl, "c", "cxx"):
        install_instructions = """
Run `make install`. By default, the installation directory will be `/usr/local/bin` and make will require `sudo` privileges.

You can override the default installation directory by overriding the `INSTALLDIR` variable. e.g. `make install INSTALLDIR=$HOME/bin` will install the script into `$HOME/bin` instead of `/usr/local/bin`.

To uninstall, run `make uninstall`. If you've modified `INSTALLDIR` during a `make install`, you'll need to supply the modified `INSTALLDIR` on `make uninstall`. eg. `make uninstall INSTALLDIR=$HOME/bin`.
""".strip()
    else:
        install_instructions = "how to install/uninstall your project"

    return install_instructions


def generate_readme(project_name, project_lang):
    build_instructions = generate_build_instructions(project_lang)
    install_instructions = generate_install_instructions(project_lang)

    readme_template = """
# $NAME

a short synopsis of what your project is about

### Introduction

what your project is about and why you wrote it

### Building

$BUILD

### Installing/Uninstalling

$INSTALL

### Usage

how to use your project with examples!

### Limitations

list out any limitations to your program here

### Technologies Used

list out your library dependencies, versions, etc

### Contributing

how to contribute to your project
"""

    readme = readme_template \
        .replace('$NAME', project_name) \
        .replace('$BUILD', build_instructions) \
        .replace('$INSTALL', install_instructions)

    with open('README.md', "w+") as f:
        f.write(readme)


def generate_main(path):
    with open(path, "w+") as f:
        f.write("""
#include <stdio.h>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        printf("%i: %s\\n", i, argv[i]);
    }
}
""")


def generate_cmake(project_dir, project_name, cmake_language_identifier):
    main_source_name = "src/main.c" if cmake_language_identifier.lower() == 'c' else "src/main.cc"
    
    cmake_template = """\
CMAKE_MINIMUM_REQUIRED(VERSION 3.0.0)
PROJECT($NAME VERSION 1.0.0)

SET(CMAKE_$LANG_STANDARD 11)
SET(CMAKE_$LANG_STANDARD_REQUIRED ON)
SET(CMAKE_EXPORT_COMPILE_COMMANDS 1)

# @PLATFORM: this works with Clang/GCC but will be an issue with MSVC
SET(CMAKE_$LANG_WARNING_FLAGS "-Wall -Wextra -Wpedantic")
SET(CMAKE_$LANG_FLAGS "${CMAKE_$LANG_FLAGS} ${CMAKE_$LANG_WARNING_FLAGS}")

SET(APP_EXE $NAME)

ADD_EXECUTABLE(${APP_EXE} %s)

TARGET_INCLUDE_DIRECTORIES(${APP_EXE} PRIVATE ${CMAKE_SOURCE_DIR}/include)
""" % main_source_name

    cmake = cmake_template \
        .replace('$NAME', project_name) \
        .replace('$LANG', cmake_language_identifier)

    with open(project_dir + "/" + "CMakeLists.txt", "w+") as f:
        f.write(cmake)


def create_git_repo(project_name):
    git_commit_msg = "mkproj " + project_name + " initial commit."
    git_cmds = [
        "git init".split(' ')
        , "git add .".split(' ')
        , ["git", "commit", "-m", git_commit_msg]
    ]

    for cmd in git_cmds:
        proc = subprocess.run(cmd)
        if proc.returncode != 0:
            error("couldn't execute %s" % cmd)
            return


def create_gitignore(language_code):
    wget = [
        "wget"
        , "https://www.toptal.com/developers/gitignore/api/%s" % language_code
        , "-q"
        , "-O"
        ".gitignore"
    ]

    if subprocess.run(wget).returncode != 0:
        error("unable to fetch .gitignore file for '%s'" % language_code)
        return

    # add additional ignores
    with open('.gitignore', 'a') as f:
        f.write("\n".join([
            "build/" # this is a common name for CMake out-of-source build
            , ".cache/"
            , "compile_commands.json" # ignore clangd compile_commands.json
            , ".vscode/"
        ]))

def create_c_project(project_name, project_dir):
    print("creating C project '%s' in '%s'" % (project_name, project_dir))
    
    mkdir("src", "include")

    # generate a file in include/ to make sure Git commit adds the 'include/' directory
    touch('include/.placeholder')

    generate_readme(project_name, 'c')

    # generate main
    with open('src/main.c', "w+") as f:
        f.write("""
#include <stdio.h>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        printf("%i: %s\\n", i, argv[i]);
    }
}
""")

    generate_cmake(project_dir, project_name, 'C')

    create_gitignore("c")

    create_git_repo(project_name)


def create_cxx_project(project_name, project_dir):
    print("creating CXX project '%s' in '%s'" % (project_name, project_dir))
    
    mkdir("src", "include")

    # generate a file in include/ to make sure Git commit adds the 'include/' directory
    touch('include/.placeholder')

    generate_readme(project_name, 'cxx')

    # generate main
    with open('src/main.cc', "w+") as f:
        f.write("""
#include <cstdio>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        std::printf("%i: %s\\n", i, argv[i]);
    }
}
""")

    generate_cmake(project_dir, project_name, 'CXX')

    create_gitignore("c++")

    create_git_repo(project_name)


def create_go_project(project_name, project_dir):
    repo = nonemptyinput("enter upstream url (e.g. github.com): ")
    username = nonemptyinput("enter your username: ")
    
    print("creating go project '%s' in '%s'" % (project_name, project_dir))

    module_path = repo + "/" + username + "/" + project_name
    mod_init = ("go mod init %s" % module_path).split(' ')
    
    proc = subprocess.run(mod_init)
    if proc.returncode != 0:
        fatal("couldn't execute '%s' in '%s'" % (mod_init, project_dir))

    command_pkg = "cmd/%s" % project_name
    mkdir(command_pkg)

    # create main.go
    with open(command_pkg + "/" + "main.go", "w+") as f:
        f.write("""
package main

import "fmt"

func main() {
	fmt.Println("Hello from mkproj.")
}
""")

    generate_readme(project_name, 'go')
    
    create_gitignore("go")

    create_git_repo(project_name)


def main(argc, argv):
    if argc < 3:
        usage(1)
    
    (project_name, project_lang, project_dir) = get_project_details(argc, argv)

    # NOTE: from this point on, all projects should assume that they are already in the project directory
    mkdir(project_dir)
    cd(project_dir)

    if oneof(project_lang, "c", "C"):
        create_c_project(project_name, project_dir)
    elif oneof(project_lang, "cxx", "cpp", "c++"):
        create_cxx_project(project_name, project_dir)
    elif oneof(project_lang, "go"):
        create_go_project(project_name, project_dir)
    else:
        fatal("unknown language '%s'" % project_lang)


if __name__ == '__main__':
    main(len(sys.argv), sys.argv)