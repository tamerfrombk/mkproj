#!/usr/bin/env python

import sys
import os
import subprocess


def error(msg):
    print("ERROR: " + msg)


def fatal(msg):
    print(msg)
    exit(1)


def usage(exit_code=0):
    print("mkproj <project_name> <language> [base_directory]")
    exit(exit_code)


def cd(dir):
    os.chdir(dir)


def pwd():
    return os.getcwd()


def mkdir(*dir_paths):
    for p in dir_paths:
        os.makedirs(p)


def touch(*files):
    for file in files:
        f = open(file, "w+")
        f.close()


def oneof(v, *values):
    for value in values:
        if v == value:
            return True
    
    return False


def get_project_details(argc, argv):
    project_name = argv[1]
    project_lang = argv[2]
    
    base_dir = argv[3] if argc == 4 else pwd()
    if not os.path.isdir(base_dir):
        fatal("'%s' is not a dir" % base_dir)

    project_dir = base_dir + "/" + project_name
    if os.path.isdir(project_dir):
        fatal("project directory '%s' already exists" % project_dir)

    return (project_name, project_lang, project_dir)


def generate_main(path):
    with open(path, "w+") as f:
        f.write("""
#include <stdio.h>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        printf("%i: %s\\n", i, argv[i]);
    }
}
""")


def generate_cmake(project_dir, project_name, cmake_language_identifier):
    main_source_name = "src/main.c" if cmake_language_identifier == 'c' else "src/main.cc"
    
    cmake_template = """\
CMAKE_MINIMUM_REQUIRED(VERSION 3.0.0)
PROJECT($NAME VERSION 1.0.0)

SET(CMAKE_$LANG_STANDARD 11)
SET(CMAKE_$LANG_STANDARD_REQUIRED ON)
SET(CMAKE_EXPORT_COMPILE_COMMANDS 1)

# @PLATFORM: this works with Clang/GCC but will be an issue with MSVC
SET(CMAKE_$LANG_WARNING_FLAGS "-Wall -Wextra -Wpedantic")
SET(CMAKE_$LANG_FLAGS "${CMAKE_$LANG_FLAGS} ${CMAKE_$LANG_WARNING_FLAGS}")

SET(APP_EXE $NAME)

ADD_EXECUTABLE(${APP_EXE} %s)

TARGET_INCLUDE_DIRECTORIES(${APP_EXE} PRIVATE ${CMAKE_SOURCE_DIR}/include)
""" % main_source_name

    cmake = cmake_template \
        .replace('$NAME', project_name) \
        .replace('$LANG', cmake_language_identifier)

    with open(project_dir + "/" + "CMakeLists.txt", "w+") as f:
        f.write(cmake)


def create_git_repo(project_name):
    git_commit_msg = "mkproj " + project_name + " initial commit."
    git_cmds = [
        "git init".split(' ')
        , "git add .".split(' ')
        , ["git", "commit", "-m", git_commit_msg]
    ]

    for cmd in git_cmds:
        proc = subprocess.run(cmd)
        if proc.returncode != 0:
            error("couldn't execute %s" % cmd)
            return


def fetch_gitignore(language_code):
    wget = [
        "wget"
        , "https://www.toptal.com/developers/gitignore/api/%s" % language_code
        , "-q"
        , "-O"
        ".gitignore"
    ]

    proc = subprocess.run(wget)

    return proc.returncode


def create_c_project(project_name, project_dir):
    print("creating C project '%s' in '%s'" % (project_name, project_dir))
    
    mkdir("src", "include")

    # generate a file in include/ to make sure Git commit adds the 'include/' directory
    touch('include/.placeholder')

    # generate main
    with open('src/main.c', "w+") as f:
        f.write("""
#include <stdio.h>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        printf("%i: %s\\n", i, argv[i]);
    }
}
""")

    generate_cmake(project_dir, project_name, 'C')

    # fetch .gitignore
    if fetch_gitignore("c") != 0:
        error("unable to fetch .gitignore file")

    # add additional ignores
    with open('.gitignore', 'a') as f:
        f.write("\n".join([
            "build/" # this is a common name for CMake out-of-source build
            , ".cache/"
            , "compile_commands.json" # ignore clangd compile_commands.json
            , ".vscode/"
        ]))

    create_git_repo(project_name)


def create_cxx_project(project_name, project_dir):
    print("creating CXX project '%s' in '%s'" % (project_name, project_dir))
    
    mkdir("src", "include")

    # generate a file in include/ to make sure Git commit adds the 'include/' directory
    touch('include/.placeholder')

    # generate main
    with open('src/main.cc', "w+") as f:
        f.write("""
#include <cstdio>

int main(int argc, char **argv) {
    for (int i = 1; i < argc; ++i) {
        std::printf("%i: %s\\n", i, argv[i]);
    }
}
""")

    generate_cmake(project_dir, project_name, 'CXX')

    # fetch .gitignore
    if fetch_gitignore("c++") != 0:
        error("unable to fetch .gitignore file")

    # add additional ignores
    with open('.gitignore', 'a') as f:
        f.write("\n".join([
            "build/" # this is a common name for CMake out-of-source build
            , ".cache/"
            , "compile_commands.json" # ignore clangd compile_commands.json
            , ".vscode/"
        ]))

    create_git_repo(project_name)


def main(argc, argv):
    if argc < 3:
        usage(1)
    
    (project_name, project_lang, project_dir) = get_project_details(argc, argv)

    # NOTE: from this point on, all projects should assume that they are already in the project directory
    mkdir(project_dir)
    cd(project_dir)

    if oneof(project_lang, "c", "C"):
        create_c_project(project_name, project_dir)
    elif oneof(project_lang, "cxx", "cpp", "c++"):
        create_cxx_project(project_name, project_dir)
    else:
        fatal("unknown language '%s'" % project_lang)


if __name__ == '__main__':
    main(len(sys.argv), sys.argv)